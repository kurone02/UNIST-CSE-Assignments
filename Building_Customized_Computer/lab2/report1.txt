Student name: Nguyen Minh Duc
Student ID: 20202026

This is the report for the exercise 1 of lab 1

Here, we are to implement a simple shadow stack to defend against buffer overflow attack.

Note that the function which has the potential to be exploited is `receive_input` as we discussed in lab 1.

The procedure of shadow stack is that we reserve a space somewhere in memory to keep the intended return address
and compare it when the function is about to end.

Hence, I made a global variable named `expected_ra` of the type `unsigned long` to save the intended return address.

This global variable lives in the .bss area of the memory, way below the current stack frame, hence, it is a safe
place to save the return address.

In the beginning of the function, I save the return address to the memory area of `expected_ra`

        expected_ra = *((unsigned long*)__builtin_frame_address(0) - 1);

Since `__builtin_frame_address(0)` returns the bottom of the current stack, and the return address lives right
on top of it, so the pointer has to be offset by 1.

At the end of the function, I read the current address again and compare it to the `expected_ra`

        found_ra = *((unsigned long*)__builtin_frame_address(0) - 1);
        if(found_ra != expected_ra) {
            raise_alarm(found_ra, expected_ra);
        }

If they are not equal, there is some corruptions in the return address, hence, `raise_alarm` is invoked.

Otherwise, the return address remains intact, which we don't need to do anything.